#!/usr/bin/env ruby
# Script to generate METHOD_DESCRIPTIONS dictionary from ri documentation
# 
# Usage: ruby generate_descriptions.rb > method_descriptions.rb
#
# This script extracts method descriptions from Ruby's ri documentation
# and generates a Ruby hash that can be used in main.rb

KLASSES = [Array, Dir, File, Hash, Integer, Float, Random, Range, Regexp, String, Symbol, Thread, Time]
EXCLUDE_KLASSES = [Module, Object, Class]

def get_method_description_from_ri(klass, method_name, is_instance)
  separator = is_instance ? '#' : '.'
  full_name = "#{klass}#{separator}#{method_name}"
  
  output = `ri --no-pager -f rdoc #{full_name} 2>&1`
  return nil unless $?.success?
  
  lines = output.lines.map(&:chomp)
  
  # Find the description section (after the separator)
  separator_found = false
  description_started = false
  description_lines = []
  
  lines.each do |line|
    # Skip until we find the separator
    if line =~ /^-{5,}/
      separator_found = true
      next
    end
    
    next unless separator_found
    
    # Skip empty lines and signature lines before description
    if !description_started
      next if line.strip.empty?
      next if line =~ /^\s*\S+\(/
      next if line =~ /^\s*\S+\s*->/
      description_started = true
    end
    
    # Now we're in description section
    # Stop at blank line or section headers
    break if line.strip.empty? && description_lines.any?
    break if line =~ /^\s*(Example|Returns|Raises|See also|Related):/i
    
    # Collect the description line
    clean_line = line.strip
    next if clean_line.empty?
    
    description_lines << clean_line
    
    # Stop after first complete sentence (period followed by space or end)
    text = description_lines.join(' ')
    if text =~ /\.\s+/ || (text.end_with?('.') && description_lines.size > 1)
      break
    end
    
    # Limit to avoid overly long descriptions
    break if text.length > 150
  end
  
  return nil if description_lines.empty?
  
  desc = description_lines.join(' ').strip
  
  # Extract just the first sentence
  if desc =~ /^([^.]+\.)(?:\s|$)/
    desc = $1
  elsif !desc.end_with?('.')
    desc = desc + '.'
  end
  
  # Clean up markup and extra spaces
  desc.gsub!(/<\/?tt>|<\/?em>|<\/?b>|<\/?i>|<\/?code>/, '')
  desc.gsub!(/\s+/, ' ')
  desc.gsub!(/:\s*$/, '.') # Replace trailing colon with period
  desc.strip!
  
  # Return only if meaningful
  desc.length > 10 && desc.length < 200 ? desc : nil
end

descriptions = {}

KLASSES.each do |klass|
  STDERR.puts "Processing #{klass}..." if ENV['VERBOSE']
  descriptions[klass.name] = {}
  
  # Get both instance and class methods
  [true, false].each do |is_instance|
    methods = if is_instance
      klass.instance_methods - EXCLUDE_KLASSES.flat_map(&:instance_methods)
    else
      klass.methods - EXCLUDE_KLASSES.flat_map(&:methods)
    end
    
    methods.each do |method_name|
      desc = get_method_description_from_ri(klass, method_name, is_instance)
      if desc && !desc.empty?
        descriptions[klass.name][method_name.to_s] = desc
        STDERR.puts "  âœ… #{is_instance ? '#' : '.'}#{method_name}" if ENV['VERBOSE']
      end
    end
  end
end

# Output as Ruby hash
puts "# Auto-generated by generate_descriptions.rb"
puts "# DO NOT EDIT MANUALLY - Run: ruby generate_descriptions.rb > method_descriptions.rb"
puts ""
puts "METHOD_DESCRIPTIONS = {"
descriptions.each do |klass, methods|
  next if methods.empty?
  puts "  '#{klass}' => {"
  methods.sort.each do |method, desc|
    # Escape single quotes in description
    escaped_desc = desc.gsub("'", "\\\\'")
    puts "    '#{method}' => '#{escaped_desc}',"
  end
  puts "  },"
end
puts "}.freeze"
